# Problem 3580: Find Consistently Improving Employees
![Medium](https://img.shields.io/badge/Level-Medium-yellow?style=for-the-badge) [![Problem Link](https://img.shields.io/badge/LeetCode-Link-orange?style=for-the-badge&logo=leetcode)](https://leetcode.com/problems/find-consistently-improving-employees/)

```sql
WITH
    recent AS (
        SELECT
            employee_id,
            review_date,
            ROW_NUMBER() OVER (
                PARTITION BY employee_id
                ORDER BY review_date DESC
            ) AS rn,
            (
                LAG(rating) OVER (
                    PARTITION BY employee_id
                    ORDER BY review_date DESC
                ) - rating
            ) AS delta
        FROM performance_reviews
    )
SELECT
    employee_id,
    name,
    SUM(delta) AS improvement_score
FROM
    recent
    JOIN employees USING (employee_id)
WHERE rn > 1 AND rn <= 3
GROUP BY 1
HAVING COUNT(*) = 2 AND MIN(delta) > 0
ORDER BY 3 DESC, 2;

```
---
## ðŸ§ Query Explanation
* `recent` CTE

  * `ROW_NUMBER() OVER (PARTITION BY employee_id ORDER BY review_date DESC) AS rn` â†’ numbers reviews per employee with `rn = 1` = **most recent**.
  * `delta = LAG(rating) OVER (PARTITION BY employee_id ORDER BY review_date DESC) - rating` â†’ for each row, computes **(more-recent rating) âˆ’ (this rowâ€™s rating)**.

    * Example: for `rn = 2`, `delta = rating(rn=1) - rating(rn=2)` (positive if the employee improved from rn=2 â†’ rn=1).

* Final query

  * `WHERE rn > 1 AND rn <= 3` â†’ keeps **the two previous reviews** (`rn = 2` and `rn = 3`) for each employee (i.e., the two reviews immediately before the most recent).
  * `HAVING COUNT(*) = 2` â†’ requires both previous reviews to exist (so we have a 3-review window).
  * `MIN(delta) > 0` â†’ ensures **both deltas are positive**, i.e., the employee improved in each step (rn3 â†’ rn2 and rn2 â†’ rn1).
  * `SUM(delta) AS improvement_score` â†’ total improvement across those two steps.
  * `ORDER BY improvement_score DESC, name` â†’ biggest improvers first.
