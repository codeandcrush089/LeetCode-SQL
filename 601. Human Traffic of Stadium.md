# Problem 601: Human Traffic of Stadium
![Hard](https://img.shields.io/badge/Level-Hard-red?style=for-the-badge) [![Problem Link](https://img.shields.io/badge/LeetCode-Link-orange?style=for-the-badge&logo=leetcode)](https://leetcode.com/problems/human-traffic-of-stadium/description/)

```sql
SELECT
    DISTINCT T1.* -- DISTINCT is used because a single row can be part of multiple consecutive sequences (e.g., the middle of a 4-row sequence)
FROM
    Stadium T1,
    Stadium T2,
    Stadium T3
WHERE
    -- Step 1: Filter to ensure all rows have people >= 100
    T1.people >= 100
    AND T2.people >= 100
    AND T3.people >= 100
    -- Step 2: Ensure T1, T2, and T3 are three consecutive rows (using the ID)
    -- T1, T2, T3 is one sequence:
    AND (
        (T1.id = T2.id - 1 AND T1.id = T3.id - 2) -- e.g., T1=5, T2=6, T3=7
        -- OR T1, T2, T3 is a sequence with T1 being the middle or end:
        OR (T1.id = T2.id + 1 AND T1.id = T3.id - 1) -- e.g., T2=5, T1=6, T3=7
        OR (T1.id = T2.id + 2 AND T1.id = T3.id + 1) -- e.g., T3=5, T2=6, T1=7
    )
ORDER BY
    T1.visit_date ASC;
```
---
## ðŸ§ Query Explanation

### **1. Self-join the `Stadium` table three times**

```sql
FROM Stadium T1, Stadium T2, Stadium T3
```

Creates three references to compare **three different rows** at a time.


### **2. Filter rows with enough people**

```sql
T1.people >= 100
AND T2.people >= 100
AND T3.people >= 100
```

Ensures **all three rows** in the sequence have at least **100 people**.


### **3. Ensure rows are consecutive by `id`**

```sql
(T1.id = T2.id - 1 AND T1.id = T3.id - 2)
OR (T1.id = T2.id + 1 AND T1.id = T3.id - 1)
OR (T1.id = T2.id + 2 AND T1.id = T3.id + 1)
```

Covers all cases where **T1 participates in a sequence of three consecutive rows**:

* T1 is the **first**
* T1 is the **middle**
* T1 is the **last**

This guarantees **three consecutive days**.


### **4. `SELECT DISTINCT T1.*`**

* A row may appear in multiple valid sequences.
* `DISTINCT` avoids duplicate rows in the final result.


### **5. `ORDER BY T1.visit_date ASC`**

Sorts the result by **visit date**.

