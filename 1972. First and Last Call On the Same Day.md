# Problem 1972: First and Last Call On the Same Day
![Hard](https://img.shields.io/badge/Level-Hard-red)

```sql
WITH
  TwoWayCalls AS (
    SELECT caller_id, recipient_id, call_time FROM Calls
    UNION ALL
    SELECT recipient_id, caller_id, call_time FROM Calls
  ),
  RankedCalls AS (
    SELECT
      caller_id,
      recipient_id,
      DATE(call_time) AS `date`,
      RANK() OVER(
        PARTITION BY caller_id, DATE(call_time)
        ORDER BY call_time ASC
      ) AS rank_asc,
      RANK() OVER(
        PARTITION BY caller_id, DATE(call_time)
        ORDER BY call_time DESC
      ) AS rank_desc
    FROM TwoWayCalls
  )
SELECT DISTINCT caller_id AS user_id
FROM RankedCalls
WHERE rank_asc = 1 OR rank_desc = 1
GROUP BY caller_id, `date`
HAVING COUNT(DISTINCT recipient_id) = 1;
```
## üßê Query Explanation
* `TwoWayCalls` ‚Üí Duplicates each call row in the opposite direction so we can treat `caller_id`/`recipient_id` uniformly (makes analysis symmetric).

* `RankedCalls` ‚Üí For each `caller_id` and `date`:

  * `rank_asc = 1` is the **earliest call** that day,
  * `rank_desc = 1` is the **latest call** that day.

* `WHERE rank_asc = 1 OR rank_desc = 1` ‚Üí Keep only the earliest and latest call rows per (user, date).

* `GROUP BY caller_id, date HAVING COUNT(DISTINCT recipient_id) = 1` ‚Üí Keep only those (user, date) groups where the earliest and the latest call were to the **same recipient** (i.e., the set of recipients among the earliest/latest rows contains exactly one distinct recipient).

.
