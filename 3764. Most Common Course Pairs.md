# Problem 3764. Most Common Course Pairs

```sql
WITH TopPerformers AS (
    -- Step 1: Identify Top-Performing Students
    SELECT
        user_id
    FROM
        course_completions
    GROUP BY
        user_id
    HAVING
        COUNT(course_id) >= 5 AND AVG(course_rating * 1.0) >= 4.0
),
CourseSequences AS (
    -- Step 2: Determine the chronological sequence of courses for top performers
    SELECT
        t1.user_id,
        t1.course_name AS second_course,
        -- Use LAG() to get the course_name completed immediately before the current one
        LAG(t1.course_name, 1) OVER (
            PARTITION BY t1.user_id
            ORDER BY t1.completion_date
        ) AS first_course
    FROM
        course_completions t1
    INNER JOIN
        TopPerformers tp ON t1.user_id = tp.user_id
)
-- Step 3: Count the frequency of each (first_course, second_course) pair
SELECT
    first_course,
    second_course,
    COUNT(*) AS transition_count
FROM
    CourseSequences
WHERE
    first_course IS NOT NULL -- Exclude the first course taken by each user (which has no preceding course)
GROUP BY
    first_course,
    second_course
ORDER BY
    transition_count DESC,
    first_course ASC,
    second_course ASC;
```

## ðŸ§ Query Explanation

### 1\. `TopPerformers` CTE (Identifying High Achievers)

This first CTE filters the users based on the criteria for "top-performing students":

  * **`GROUP BY user_id`**: Groups the records by student.
  * **`HAVING COUNT(course_id) >= 5`**: Ensures the student completed at least 5 courses.
  * **`HAVING AVG(course_rating * 1.0) >= 4.0`**: Calculates the average rating (using `* 1.0` for floating-point division if the database treats `AVG` of integers as an integer) and ensures it is 4.0 or higher.

### 2\. `CourseSequences` CTE (Finding Consecutive Pairs)

This CTE takes the courses completed *only* by the `TopPerformers` and establishes the chronological order:

  * **`INNER JOIN TopPerformers tp ON t1.user_id = tp.user_id`**: Filters the main table to include only the records of the qualified top performers.
  * **`LAG(t1.course_name, 1) OVER (...) AS first_course`**: This is the core of the sequence finding:
      * **`PARTITION BY t1.user_id`**: The `LAG` function restarts the ordering/sequencing for each distinct user.
      * **`ORDER BY t1.completion_date`**: Defines the chronological order of courses for the current user.
      * **`LAG(..., 1)`**: Retrieves the value of `course_name` from the **previous row** (offset of 1) within the current user's partition, based on the completion date. This previous course becomes the `first_course` in the pair, and the current course is the `second_course`.

### 3\. Final Query (Counting Transitions and Ordering)

The final `SELECT` statement processes the generated pairs:

  * **`WHERE first_course IS NOT NULL`**: Removes the very first course taken by each student, as it has no preceding course (`LAG` returns `NULL` for the first row in a partition).
  * **`COUNT(*) AS transition_count`**: Counts how many times each unique `(first_course, second_course)` pair appears.
  * **`GROUP BY first_course, second_course`**: Groups the pairs for the counting.
  * **`ORDER BY transition_count DESC, first_course ASC, second_course ASC`**: Sorts the results as required: by frequency (descending) and then by course names (ascending) for tie-breaking.
