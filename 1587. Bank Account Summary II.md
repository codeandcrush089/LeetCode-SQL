# Problem 1587: Bank Account Summary II
![Easy](https://img.shields.io/badge/Level-Easy-brightgreen)

```sql
-- Solution to report the name and balance of users with a balance higher than 10000.
-- All accounts start with a balance of 0, so the current balance is the sum of all transactions.

SELECT
    U.name,
    T_Agg.balance
FROM
    Users U
INNER JOIN
    -- 1. Calculate the total balance for each account
    (
        SELECT
            account,
            SUM(amount) AS balance
        FROM
            Transactions
        GROUP BY
            account
    ) T_Agg ON U.account = T_Agg.account
WHERE
    -- 2. Filter the results to only include accounts where the balance is greater than 10000
    T_Agg.balance > 10000
;
```
---


## 1Ô∏è‚É£ Approach

Goal:
Report **user name + balance** for those users whose **account balance > 10000**.

High-level idea:

1. First, **calculate the total balance per account** using the `Transactions` table (since all accounts start from 0).
2. Then, **join** those balances with the `Users` table to map each account to its **user name**.
3. Finally, **filter** to keep only users with a balance **greater than 10000**.

This is done using:

* An **aggregation subquery** on `Transactions`
* An **INNER JOIN** with `Users`
* A **WHERE** filter on the aggregated balance


## 2Ô∏è‚É£ Logic (Step-by-step)

### Step 1: Aggregate balance per account

```sql
SELECT
    account,
    SUM(amount) AS balance
FROM
    Transactions
GROUP BY
    account
```

* For each `account`, sum all `amount` values.
* This gives the **current balance** for each account (because initial balance is 0).
* Result: a temporary table `T_Agg` like:

| account | balance |
| ------- | ------- |
| A1      | 15000   |
| A2      | 8000    |
| A3      | 22000   |



### Step 2: Join with Users to get names

```sql
FROM
    Users U
INNER JOIN
    T_Agg ON U.account = T_Agg.account
```

* `Users` contains user info like `name`, `account`, etc.
* `T_Agg` contains `account` and its computed `balance`.
* Joining on `account` lets us attach the **balance** to the **user** who owns that account.

After join, result looks like:

| name  | account | balance |
| ----- | ------- | ------- |
| Ravi  | A1      | 15000   |
| Meena | A2      | 8000    |
| Arjun | A3      | 22000   |



### Step 3: Filter accounts with balance > 10000

```sql
WHERE
    T_Agg.balance > 10000
```

* Keeps only rows where the **final balance is more than 10000**.
* Final output columns:

```sql
SELECT
    U.name,
    T_Agg.balance
```

Result example:

| name  | balance |
| ----- | ------- |
| Ravi  | 15000   |
| Arjun | 22000   |



## 3Ô∏è‚É£ Time & Space Complexity

Let:

* `N` = number of rows in `Transactions`
* `M` = number of rows in `Users`

### ‚è± Time Complexity

1. **Aggregation on Transactions**
   `GROUP BY account` + `SUM(amount)` over `N` rows
   ‚Üí **O(N)**

2. **Join with Users**
   Joining `Users (M rows)` with aggregated result (`K` accounts, where `K ‚â§ N`)

   * With proper indexing (e.g., on `Users.account` and aggregated `account`): approx **O(M + K)**
   * Typically still **O(N + M)** overall.

So, total time complexity ‚âà **O(N + M)**



### üíæ Space Complexity

* The subquery `T_Agg` stores **one row per distinct account**, up to `K` rows (`K ‚â§ N`)
  ‚Üí **O(K)** extra space.
* Output size is at most `M` rows (one per user) ‚Üí **O(M)**.

Overall auxiliary space ‚âà **O(K)** (dominant from aggregation).

